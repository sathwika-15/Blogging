<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Techy Girl! Blog</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>Techy Girl! Blog</h1>
        <nav class="nav" role="navigation" aria-label="Main Navigation">
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="blog.html">The Blog</a></li>
                <li><a href="about.html">About</a></li>
                <li><a href="contact.html">Contact</a></li>
            </ul>
        </nav>
    </header>

    <main>
        <div class="accordion-container">
            <button class="accordion">Blog Post 1</button>
            <div class="panel">
                <p><i>Date: August 7, 2024</i></p>
                <p><strong>Starting My Blogging Journey & Solving a LeetCode Problem</strong><br>
                    Hello and welcome to my blog! ðŸŽ‰ Today marks the beginning of my blogging adventure.<br> 
                    Iâ€™ve just finished setting up this website and I'm excited to share my journey with you.<br> 
                    To kick things off, I tackled a problem from LeetCode titled "Length of Last Word," which is categorized as an easy-level challenge.<br>
                    <strong>Problem Overview:</strong>The goal of this problem is to find the length of the last word in a given string. Words are separated by spaces, and trailing spaces should be ignored.<br>
                    <strong>Solution Approach:</strong>In this problem, we mainly deal with string and array manipulation.Here's how I solved it using Java<br>
                    The split(" ") method breaks the string into an array of words wherever there is a space. This handles multiple spaces and ensures we get a clean list of words.<br>
                    The last word is accessed using arr[arr.length - 1]. This is because arrays are zero-indexed, so the last element is at index arr.length - 1.<br>
                    Finally, arr[arr.length - 1].length() gives us the length of the last word.<br>
                    That wraps up my first day of learning and blogging.<br>
                    I hope you found this breakdown helpful! Stay tuned for more updates as I continue exploring coding problems and sharing my experiences.<br>
                    If you have any questions or suggestions, feel free to mail me.
                </p>
            </div>

            <button class="accordion">Blog Post 2</button>
            <div class="panel">
                <p><i>Date: August 8, 2024</i></p>
                <p><strong>Tackling the "Plus One" LeetCode Problem</strong><br>
                    Welcome to Day 2 of my blogging journey! Today, I tackled an "Easy" level LeetCode problem called "Plus One." This problem might seem straightforward, but it offers a great opportunity to practice handling arrays and edge cases. Letâ€™s dive into the problem and the solution I came up with.<br>
                    <strong>Problem Statement:</strong><br>
                    The task is to increment a large integer represented by an array of digits. Each element in the array corresponds to a single digit of the integer, with the most significant digit at the start of the array. The integer does not contain any leading zeroes.<br>
                    <strong>Example:</strong><br>
                    Input: digits = [1, 2, 3]<br>
                    Output: [1, 2, 4]<br>
                    <strong>Solution Approach:</strong><br>
                    I started by looping through the array from the last index to the first. This is because incrementing the number starts from the least significant digit (rightmost).<br>
                    If the current digit is less than 9, I simply incremented it by 1 and returned the updated array.<br>
                    If the digit is 9, setting it to 0 handles the carry-over for that digit. The loop then moves to the next more significant digit to the left.<br>
                    If all digits are 9, the loop sets all of them to 0. In this case, I create a new array with an extra size to accommodate the new digit (e.g., 999 becomes 1000). The new array is initialized with a 1 at the start.<br>
                    Thatâ€™s it for todayâ€™s coding session! The "Plus One" problem is a great example of how to handle array manipulations and edge cases effectively. I hope you found this explanation helpful and that it gives you a clearer understanding of how to approach similar problems.<br>
                    Stay tuned for more coding challenges and solutions in the coming days....!
                </p>
            </div>
            <button class="accordion">Blog Post 3</button>
            <div class="panel">
                <p><i>Date: August 9, 2024</i></p>
                <p><strong>Tremendous Third Day of Blogging</strong><br>
                    Today marks the tremendous third day of my blogging journey, and I'm excited to share my progress with you!<br>
                    <strong>Tackling the LeetCode Problem</strong><br>
                    Today's focus was on solving an easy-level LeetCode problem known as "Remove Duplicates from Sorted List". Let me walk you through the problem and the solution.<br>
                    <strong>Problem Statement:</strong><br>
                    Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.<br>
                    <strong>Example:</strong><br>
                    Input: head = [1,1,2]<br>
                    Output: [1,2]<br>
                    <strong>Solution Explanation:</strong><br>
                    I started by checking if the input list is null. If the list is empty, we immediately return null since there are no nodes to process.<br>
                    and then we initialize a ListNode reference named temp to the head of the list.<br>
                    The loop continues as long as there is a next node to check. It will stop when temp.next is null, indicating that temp is at the last node of the list.<br>
                    Inside the loop, we compare the value of the current node (temp.val) with the value of the next node (temp.next.val). If they are the same, we identify it as a duplicate. To remove the duplicate, we update temp.next to skip over the duplicate node (temp.next.next), effectively removing the duplicate from the list.<br>
                    If the values are different, we simply move the temp pointer to the next node (temp = temp.next).<br>
                    This problem has been a great exercise in understanding linked lists more proficiently and reinforcing the concepts of traversal and node manipulation.<br>
                    <strong>Personal Update</strong><br>
                    So, hereâ€™s a little personal update: this marks just the third day of my blogging journey. Iâ€™m planning to take a short break due to some personal reasons. Iâ€™ll be interrupting my blogging for a few days but will be back on Tuesday. When I return, Iâ€™ll update you with all the information and insights Iâ€™ve gathered over these days.<br>
                    See you then!
                </p>
            </div>
            <button class="accordion">Blog Post 4</button>
            <div class="panel">
                <p><i>Date: August 10, 2024</i></p>
                <p>Blog 4 content goes here.....</p>
            </div>
        </div>
    </main>

    <footer>
        <p>&copy; 2024 Techy Girl! All rights reserved.</p>
    </footer>
    
    <script src="script.js"></script>
</body>
</html>
